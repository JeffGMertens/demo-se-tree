<!doctype html>
<html lang="nl">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Faceted Tree – Import & Export (Hoogspanningsstation)</title>
  <style>
    :root { --bg:#f8fafc; --card:#fff; --ink:#0f172a; --muted:#64748b; --ring:#2563eb; --ok:#16a34a; --shadow:0 10px 30px rgba(2,6,23,.08); --radius:16px; }
    *{box-sizing:border-box}
    body{margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial;background:var(--bg);color:var(--ink)}
    header{position:sticky;top:0;z-index:30;background:linear-gradient(180deg,#fff,rgba(255,255,255,.85));border-bottom:1px solid #e2e8f0;padding:14px 16px;backdrop-filter:blur(6px)}
    h1{margin:0;font-size:18px}
    .wrap{max-width:1300px;margin:0 auto;padding:16px;display:grid;gap:16px;grid-template-columns:320px 1fr}
    @media (max-width:1024px){.wrap{grid-template-columns:1fr}}
    .card{background:var(--card);border:1px solid #e2e8f0;border-radius:var(--radius);box-shadow:var(--shadow)}

    /* Facets */
    .facets{padding:14px;position:sticky;top:78px;max-height:calc(100dvh - 100px);overflow:auto}
    .facet{padding:8px 4px}
    .facet+.facet{border-top:1px dashed #e2e8f0;margin-top:10px;padding-top:14px}
    .facet h3{margin:0 0 8px;font-size:13px;color:var(--muted);letter-spacing:.06em;text-transform:uppercase}
    .option{display:flex;justify-content:space-between;align-items:center;gap:8px;padding:8px 10px;border-radius:10px;cursor:pointer}
    .option:hover{background:#f1f5f9}
    .count{color:var(--muted);font-variant-numeric:tabular-nums}

    /* Controls */
    .controls{display:flex;gap:12px;align-items:center;padding:10px 12px;border-bottom:1px solid #e2e8f0;flex-wrap:wrap}
    .toggle{display:inline-flex;border:1px solid #e2e8f0;border-radius:999px;overflow:hidden}
    .toggle button{padding:6px 10px;border:0;background:#fff;cursor:pointer;font-size:12px}
    .toggle button.active{background:#eef2ff;color:#4338ca}
    .btn{appearance:none;border:1px solid #e2e8f0;background:#fff;border-radius:10px;padding:8px 10px;cursor:pointer}

    /* Tree */
    .tree-panel{display:flex;flex-direction:column;min-height:500px}
    .toolbar{padding:10px 12px;border-bottom:1px solid #e2e8f0;display:flex;align-items:center;gap:12px;flex-wrap:wrap}
    .legend{padding:10px 12px;color:var(--muted);font-size:12px;border-bottom:1px solid #e2e8f0;display:flex;gap:16px;flex-wrap:wrap}
    .legend .swatch{width:10px;height:10px;border-radius:999px;display:inline-block;margin-right:6px;vertical-align:middle}
    .import-drop{display:none;position:fixed;inset:0;background:rgba(37,99,235,.08);border:2px dashed var(--ring);border-radius:8px;align-items:center;justify-content:center;z-index:50;color:#1e293b;font-size:18px}
    .import-drop.active{display:flex}

    svg{display:block;width:100%;height:70vh;max-height:800px}
    .link{stroke:#cbd5e1;stroke-width:2;fill:none}
    .link.emph{stroke:#94a3b8;stroke-width:3}
    .node{cursor:pointer}
    .node circle{r:7;fill:#fff;stroke:#94a3b8;stroke-width:2}
    .node.match circle{stroke:var(--ok)}
    .node.dim circle{opacity:.35}
    .node text{font-size:12px;dominant-baseline:middle;fill:var(--ink)}
    .node.dim text{opacity:.35}
  </style>
</head>
<body>
<header><h1>Faceted Tree – Import & Export (Hoogspanningsstation)</h1></header>

<div class="wrap">
  <!-- FACETS -->
  <aside class="card facets" id="facets"></aside>

  <!-- TREE PANEL -->
  <section class="card tree-panel">
    <div class="controls">
      <div class="toggle" id="facetMode">
        <button data-mode="OR" class="active" title="Minstens één optie per facet">OR</button>
        <button data-mode="AND" title="Alle gekozen opties binnen facet moeten voorkomen">AND</button>
      </div>
      <button class="btn" id="clearBtn">Wis filters</button>
      <button class="btn" id="exportBtn">Exporteer JSON</button>
      <input type="file" id="fileInput" accept="application/json" style="display:none" />
      <button class="btn" id="importBtn">Importeer JSON</button>
      <span id="status" style="margin-left:auto;color:var(--muted);font-size:12px"></span>
    </div>
    <div class="toolbar">
      <label><input type="checkbox" id="hideNon"/> Verberg niet‑matchende knopen</label>
      <label><input type="checkbox" id="emphPath" checked/> Benadruk paden naar matches</label>
      <label><input type="checkbox" id="autoFit" checked/> Auto-fit</label>
    </div>
    <div class="legend">
      <span><span class="swatch" style="background:transparent;border:2px solid var(--ok);"></span>match</span>
      <span><span class="swatch" style="background:#94a3b8;"></span>verbinding naar match</span>
      <span><span class="swatch" style="background:#cbd5e1;"></span>overige verbinding</span>
    </div>
    <svg id="tree"></svg>
  </section>
</div>
<div class="import-drop" id="dropZone">Laat hier je JSON los om te importeren</div>

<script>
// ---------------------------- DEFAULT DATA ----------------------------------
let NODES = [
  { id:'sys',  name:'Systeem',             parent:null,         discipline:'civiel',   fase:'Fase 1' },
  { id:'st1',  name:'Station A (150 kV)',  parent:'sys',        discipline:'civiel',   fase:'Fase 1' },
  { id:'bay1', name:'Bay 1 (Invoer)',      parent:'st1',        discipline:'primair',  fase:'Fase 1' },
  { id:'cb1',  name:'Schakelaar CB‑101',   parent:'bay1',       discipline:'primair',  fase:'Fase 1', vlag:'OGG' },
  { id:'ds1',  name:'Scheider DS‑101',     parent:'bay1',       discipline:'primair',  fase:'Fase 1' },
  { id:'ct1',  name:'Stroomtrafo CT‑101',  parent:'bay1',       discipline:'secundair',fase:'Fase 1' },
  { id:'bay2', name:'Bay  2 (Uitvoer)',    parent:'st1',        discipline:'primair',  fase:'Fase 2' },
  { id:'cb2',  name:'Schakelaar CB‑102',   parent:'bay2',       discipline:'primair',  fase:'Fase 2', vlag:'OGG' },
  { id:'vt1',  name:'Spanningstrafo VT‑102',parent:'bay2',      discipline:'secundair',fase:'Fase 2' },
  { id:'bk1',  name:'Besturingskast BK‑1', parent:'st1',        discipline:'secundair',fase:'Fase 1' },
  { id:'tr1',  name:'Telecomrack TR‑1',    parent:'st1',        discipline:'telecom',  fase:'Fase 1' },
  { id:'fund1',name:'Fundatie gebouw',     parent:'st1',        discipline:'civiel',   fase:'Fase 1' },
  { id:'st2',  name:'Station B (380 kV)',  parent:'sys',        discipline:'civiel',   fase:'Fase 2' },
  { id:'bay3', name:'Bay 3 (Invoer)',      parent:'st2',        discipline:'primair',  fase:'Fase 2' },
  { id:'cb3',  name:'Schakelaar CB‑201',   parent:'bay3',       discipline:'primair',  fase:'Fase 2', vlag:'OGG' },
  { id:'ds3',  name:'Scheider DS‑201',     parent:'bay3',       discipline:'primair',  fase:'Fase 2' },
  { id:'ct3',  name:'Stroomtrafo CT‑201',  parent:'bay3',       discipline:'secundair',fase:'Fase 2' },
  { id:'bk2',  name:'Besturingskast BK‑2', parent:'st2',        discipline:'secundair',fase:'Fase 2' },
  { id:'tm1',  name:'Telecommast TM‑1',    parent:'st2',        discipline:'telecom',  fase:'Fase 2', vlag:'OGG' },
  { id:'fund2',name:'Fundatie veld',       parent:'st2',        discipline:'civiel',   fase:'Fase 2' }
];

const FACETS = [
  { key:'discipline', label:'Discipline', type:'value' },
  { key:'fase',       label:'Categorie: Fase', type:'value' },
  { key:'vlag',       label:'Vlag', type:'value' },
  { key:'hier',       label:'Hiërarchie', type:'hierarchical', map:(node)=> pathToRoot(node).map(n=>n.name) }
];

// ---------------------------- GRAPH PREP ------------------------------------
let byId, children, roots, collapsed = new Set();
function rebuildIndexes(){
  byId = new Map(NODES.map(n=>[n.id,n]));
  children = new Map(NODES.map(n=>[n.id,[]]));
  for(const n of NODES) if(n.parent) children.get(n.parent)?.push(n);
  roots = NODES.filter(n=>n.parent===null);
}
rebuildIndexes();

function pathToRoot(node){ const arr=[]; let cur=node; while(cur){ arr.unshift(cur); cur = cur.parent? byId.get(cur.parent) : null; } return arr; }

// ---------------------------- STATE -----------------------------------------
const state = { facetMode:'OR', selected:Object.fromEntries(FACETS.map(f=>[f.key,new Set()])), hideNon:false, emphPath:true };
let ALL_VALUES = {};
function rebuildFacetUniverse(){
  ALL_VALUES = Object.fromEntries(FACETS.map(f=>[f.key,new Set()]));
  for (const n of NODES){
    for (const f of FACETS){
      if (f.type==='value'){ const v=n[f.key]; if(v!=null) ALL_VALUES[f.key].add(String(v)); }
      else if (f.type==='hierarchical'){ f.map(n).forEach(x=>ALL_VALUES[f.key].add(String(x))); }
    }
  }
}
rebuildFacetUniverse();

// ---------------------------- FILTERING -------------------------------------
function nodeMatches(node){
  for (const f of FACETS){
    const sel = state.selected[f.key]; if(!sel || sel.size===0) continue;
    if (f.type==='value'){
      const val=node[f.key]; if(val==null) return false;
      if (state.facetMode==='OR'){ if (![...sel].some(v=>v===String(val))) return false; }
      else { if (![...sel].every(v=>v===String(val))) return false; }
    } else if (f.type==='hierarchical'){
      const vals=new Set(f.map(node).map(String));
      if (state.facetMode==='OR'){ if (![...sel].some(v=>vals.has(v))) return false; }
      else { if (![...sel].every(v=>vals.has(v))) return false; }
    }
  }
  return true;
}

function computeFacetCounts(){
  const counts = {}; for (const f of FACETS) counts[f.key] = Object.fromEntries([...ALL_VALUES[f.key]].map(v=>[v,0]));
  for (const f of FACETS){
    const partial = NODES.filter(n=> FACETS.every(ff=>{
      if (ff.key===f.key) return true; const sel = state.selected[ff.key]; if (!sel || sel.size===0) return true;
      if (ff.type==='value'){ const val=n[ff.key]; if(val==null) return false; return state.facetMode==='OR' ? [...sel].some(v=>v===String(val)) : [...sel].every(v=>v===String(val)); }
      if (ff.type==='hierarchical'){ const vals=new Set(ff.map(n).map(String)); return state.facetMode==='OR' ? [...sel].some(v=>vals.has(v)) : [...sel].every(v=>vals.has(v)); }
      return true;
    }));
    for (const n of partial){
      if (f.type==='value'){ const v=n[f.key]; if(v!=null) counts[f.key][String(v)] = (counts[f.key][String(v)]||0)+1; }
      if (f.type==='hierarchical'){ for (const v of new Set(FACETS.find(x=>x.key==='hier').map(n).map(String))) counts[f.key][v] = (counts[f.key][v]||0)+1; }
    }
  }
  return counts;
}

// ---------------------------- LAYOUT (tidy tree) ----------------------------
function computeLayout(){
  const nodePos = new Map(); const linkPos=[]; const depthGap=160, levelGap=60; let yCursor=0;
  function isHiddenByCollapse(n){ let cur=n; while(cur && cur.parent){ if (collapsed.has(cur.parent)) return true; cur = byId.get(cur.parent);} return false; }
  function visibleChildren(id){ return (children.get(id)||[]).filter(ch=>!isHiddenByCollapse(ch)); }
  function dfs(node,depth){
    const kids = visibleChildren(node.id);
    if (kids.length===0){ const y = yCursor++*levelGap+30; nodePos.set(node.id,{x:depth*depthGap+40,y}); return {min:y,max:y,y}; }
    let min=Infinity,max=-Infinity; const spans=[];
    for (const k of kids){ const span = dfs(k,depth+1); spans.push({k,span}); min=Math.min(min,span.min); max=Math.max(max,span.max); }
    const y=(min+max)/2; nodePos.set(node.id,{x:depth*depthGap+40,y});
    for (const {k} of spans){ const p=nodePos.get(node.id), c=nodePos.get(k.id); linkPos.push({x1:p.x,y1:p.y,x2:c.x,y2:c.y,pid:node.id,cid:k.id}); }
    return {min,max,y};
  }
  for (const r of roots) dfs(r,0);
  return {nodePos,linkPos,height:Math.max(300,(yCursor+1)*levelGap)};
}

// ---------------------------- RENDERING --------------------------------------
const facetsEl = document.getElementById('facets');
const svg = document.getElementById('tree');
const statusEl = document.getElementById('status');

function renderFacets(){
  const counts = computeFacetCounts();
  facetsEl.innerHTML='';
  for (const f of FACETS){
    const sec=document.createElement('section'); sec.className='facet';
    const h=document.createElement('h3'); h.textContent=f.label; sec.appendChild(h);
    const vals=[...ALL_VALUES[f.key]].sort((a,b)=>a.localeCompare(b,'nl'));
    for (const v of vals){
      const lab=document.createElement('label'); lab.className='option';
      const input=document.createElement('input'); input.type='checkbox'; input.checked=state.selected[f.key].has(v);
      input.onchange=()=>{ if(input.checked) state.selected[f.key].add(v); else state.selected[f.key].delete(v); update(); };
      const span=document.createElement('span'); span.textContent=v;
      const cnt=document.createElement('span'); cnt.className='count'; cnt.textContent=counts[f.key][v]||0;
      lab.appendChild(input); lab.appendChild(span); lab.appendChild(cnt); sec.appendChild(lab);
    }
    facetsEl.appendChild(sec);
  }
}

function clearSVG(){ while(svg.firstChild) svg.removeChild(svg.firstChild); }

function renderTree(){
  const {nodePos,linkPos,height} = computeLayout(); svg.setAttribute('height',height); clearSVG();
  const matches = new Set(NODES.filter(nodeMatches).map(n=>n.id));
  const hideNon = document.getElementById('hideNon').checked;
  const emphPath = document.getElementById('emphPath').checked;

  for (const L of linkPos){
    const path = document.createElementNS('http://www.w3.org/2000/svg','path');
    const mx=(L.x1+L.x2)/2; const d=`M ${L.x1},${L.y1} C ${mx},${L.y1} ${mx},${L.y2} ${L.x2},${L.y2}`;
    path.setAttribute('d',d);
    const emph = emphPath && (matches.has(L.cid) || matches.has(L.pid));
    path.setAttribute('class', emph? 'link emph':'link');
    svg.appendChild(path);
  }

  for (const n of NODES){
    const pos = byId.get(n.id) ? computeLayout.cache?.nodePos?.get(n.id) || null : null; // not used; we'll use our nodePos
  }
  for (const n of NODES){
    const pos = nodePos.get(n.id); if (!pos) continue; // hidden by collapse
    const g = document.createElementNS('http://www.w3.org/2000/svg','g');
    const isMatch = matches.has(n.id);
    const dim = !isMatch && !hideNon;
    g.setAttribute('class','node'+(isMatch?' match':'')+(dim?' dim':''));
    g.setAttribute('transform',`translate(${pos.x},${pos.y})`);
    g.addEventListener('click',(e)=>{ e.stopPropagation(); if((children.get(n.id)||[]).length) toggleCollapse(n.id); });

    const circle = document.createElementNS('http://www.w3.org/2000/svg','circle'); g.appendChild(circle);
    const label = document.createElementNS('http://www.w3.org/2000/svg','text');
    label.setAttribute('x',12); label.textContent = n.name + ((children.get(n.id)||[]).length ? (collapsed.has(n.id)?'  ▶':'  ▼') : '');
    g.appendChild(label);
    svg.appendChild(g);
  }

  if (document.getElementById('autoFit').checked) fitToContent();
}

function toggleCollapse(id){ if (collapsed.has(id)) collapsed.delete(id); else collapsed.add(id); renderTree(); }

function fitToContent(){ const bbox=svg.getBBox(); const pad=20; const minX=Math.max(0,bbox.x-pad), minY=Math.max(0,bbox.y-pad); const w=Math.max(100,bbox.width+pad*2), h=Math.max(100,bbox.height+pad*2); svg.setAttribute('viewBox',`${minX} ${minY} ${w} ${h}`); }

function update(){ rebuildFacetUniverse(); renderFacets(); renderTree(); status(''); }

// ---------------------------- EXPORT ----------------------------------------
function currentSelection(){ const active=Object.fromEntries(Object.keys(state.selected).map(k=>[k,[...state.selected[k]]])); const any=Object.values(active).some(a=>a.length>0); return {active,any}; }
function buildExport(){
  const { any } = currentSelection();
  const ids = new Set((any ? NODES.filter(nodeMatches) : NODES).map(n=>n.id));
  const nodes = (any ? NODES.filter(n=>ids.has(n.id)) : NODES).map(n=>({ id:n.id, name:n.name, parent:n.parent ?? null, discipline:n.discipline ?? null, fase:n.fase ?? null, vlag:n.vlag ?? null }));
  const links = NODES.filter(n=>n.parent && ids.has(n.id) && ids.has(n.parent)).map(n=>({ from:n.parent, to:n.id }));
  return { version:1, generatedAt:new Date().toISOString(), filters:Object.fromEntries(Object.entries(state.selected).map(([k,set])=>[k,[...set]])), count:{ nodes:nodes.length, links:links.length }, nodes, links };
}
function downloadJSON(filename, obj){ const blob=new Blob([JSON.stringify(obj,null,2)],{type:'application/json'}); const url=URL.createObjectURL(blob); const a=document.createElement('a'); a.href=url; a.download=filename; document.body.appendChild(a); a.click(); setTimeout(()=>{ URL.revokeObjectURL(url); a.remove(); },0); }

// ---------------------------- IMPORT ----------------------------------------
function status(msg){ statusEl.textContent = msg || ''; }
function parseImported(json){
  // Accept {nodes:[...], links:[...]}, optionally {filters:...}
  if (!json || !Array.isArray(json.nodes)) throw new Error('JSON mist "nodes" array');
  const nodes = json.nodes.map(n=>({
    id: String(n.id),
    name: String(n.name ?? n.id),
    parent: n.parent===undefined? null : (n.parent===null? null : String(n.parent)),
    discipline: n.discipline ? String(n.discipline) : null,
    fase: n.fase ? String(n.fase) : null,
    vlag: n.vlag ? String(n.vlag) : null
  }));
  // Build parent from links if provided
  if (Array.isArray(json.links)){
    const pmap = new Map();
    for (const l of json.links){ const from=String(l.from), to=String(l.to); if (pmap.has(to) && pmap.get(to)!==from) throw new Error(`Node ${to} heeft meerdere ouders in links`); pmap.set(to, from); }
    for (const n of nodes){ if (pmap.has(n.id)) n.parent = pmap.get(n.id); }
  }
  // Validate: ids unique, parents exist or null, no cycles
  const ids = new Set(); for (const n of nodes){ if (ids.has(n.id)) throw new Error(`Dubbele id: ${n.id}`); ids.add(n.id); }
  const idSet = new Set(nodes.map(n=>n.id));
  for (const n of nodes){ if (n.parent && !idSet.has(n.parent)) throw new Error(`Parent niet gevonden voor ${n.id}: ${n.parent}`); }
  // Cycle check via DFS
  const kids = new Map([...idSet].map(id=>[id,[]]));
  for (const n of nodes) if (n.parent) kids.get(n.parent).push(n.id);
  const seen=new Set(), stack=new Set();
  function dfs(u){ if (stack.has(u)) throw new Error('Cyclische relatie gedetecteerd bij '+u); if (seen.has(u)) return; stack.add(u); for (const v of kids.get(u)||[]) dfs(v); stack.delete(u); seen.add(u); }
  for (const n of nodes){ if (!n.parent) dfs(n.id); }
  return nodes;
}
async function importFromFile(file){
  try{
    const text = await file.text();
    const json = JSON.parse(text);
    const nodes = parseImported(json);
    NODES = nodes; collapsed = new Set(); rebuildIndexes(); state.selected = Object.fromEntries(FACETS.map(f=>[f.key,new Set()])); update(); status(`Geïmporteerd: ${nodes.length} nodes`);
  } catch(err){ console.error(err); alert('Import mislukt: '+err.message); status('Import mislukt'); }
}

// Drag & drop
const drop = document.getElementById('dropZone');
['dragenter','dragover'].forEach(ev=>document.addEventListener(ev,(e)=>{ e.preventDefault(); drop.classList.add('active'); }));
['dragleave','drop'].forEach(ev=>document.addEventListener(ev,(e)=>{ e.preventDefault(); drop.classList.remove('active'); }));
drop.addEventListener('drop',(e)=>{ const file = e.dataTransfer.files?.[0]; if(file) importFromFile(file); });

// ---------------------------- CONTROLS --------------------------------------
document.getElementById('clearBtn').onclick=()=>{ for(const f of FACETS) state.selected[f.key].clear(); update(); };

document.getElementById('exportBtn').onclick=()=>{ const data=buildExport(); const name = Object.values(data.filters).some(a=>a.length) ? 'hoogspanningsstation-filter.json' : 'hoogspanningsstation-all.json'; downloadJSON(name,data); };

const fileInput = document.getElementById('fileInput');
fileInput.onchange = ()=>{ const f=fileInput.files?.[0]; if(f) importFromFile(f); };
document.getElementById('importBtn').onclick=()=> fileInput.click();

const facetMode = document.getElementById('facetMode');
facetMode.addEventListener('click',(e)=>{ if(e.target.tagName!=='BUTTON') return; for(const b of facetMode.querySelectorAll('button')) b.classList.remove('active'); e.target.classList.add('active'); state.facetMode=e.target.dataset.mode; update(); });

document.getElementById('hideNon').onchange=(e)=>{ state.hideNon=e.target.checked; renderTree(); };
document.getElementById('emphPath').onchange=()=> renderTree();
document.getElementById('autoFit').onchange=()=> renderTree();

// ---------------------------- INIT ------------------------------------------
update();
</script>
</body>
</html>
